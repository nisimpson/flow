package flow

import (
	"context"
	"errors"
	"sync"
)

// FlowError represents a collection of errors that occurred during [Flow] processing.
// It provides thread-safe error collection and aggregation capabilities.
type FlowError struct {
	sync.Mutex         // Embedded mutex for thread-safe operations
	hasErrors  bool    // Indicates if any errors have been collected
	errs       []error // Slice of collected errors
}

// Append adds an error to the [FlowError] collection in a thread-safe manner.
// Nil errors won't contribute to the joined error text generated by [FlowError.Error].
func (f *FlowError) Append(err error) {
	f.Lock()
	defer f.Unlock()
	f.errs = append(f.errs, err)
	if err != nil {
		f.hasErrors = true
	}
}

// Error implements the error interface, returning all collected errors joined together.
// Returns a string representation of all collected errors.
func (f *FlowError) Error() string {
	f.Lock()
	defer f.Unlock()
	return errors.Join(f.errs...).Error()
}

// flowErrorCtxKey is a context key type for storing [FlowError] in context.
type flowErrorCtxKey struct{}

// setFlowErrorContext creates a new context containing the provided [FlowError].
func setFlowErrorContext(ctx context.Context, fe *FlowError) context.Context {
	return context.WithValue(ctx, flowErrorCtxKey{}, fe)
}

// getFlowErrorContext retrieves the [FlowError] from the context.
// Panics if the FlowError is not found in the context.
func getFlowErrorContext(ctx context.Context) *FlowError {
	value := ctx.Value(flowErrorCtxKey{})
	if fe, ok := value.(*FlowError); ok {
		return fe
	}
	panic("flow error context not found")
}

// SetError adds an error to the [FlowError] stored in the context.
func SetError(ctx context.Context, err error) {
	fe := getFlowErrorContext(ctx)
	fe.Append(err)
}
